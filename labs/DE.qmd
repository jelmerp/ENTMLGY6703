---
title: "Week 4 lab: RNA-seq differential expression analysis"
author: Jelmer Poelstra
date: 2024-02-02
editor: visual
execute: 
  eval: true
  cache: true
knitr:
  opts_chunk:
    out.width: "85%"
number-depth: 3
project:
  execute-dir: project
editor_options: 
  chunk_output_type: console
---

<br>

## Introduction

Last week, you explored the RNA-seq reads from the 2023 Molecular Ecology paper
["*Two avian Plasmodium species trigger different transcriptional responses on their vector Culex pipiens*"](https://doi.org/10.1111/mec.17240),
as well as the _Culex pipiens_ reference genome files.

In yesterday's lecture, you learned about the steps to generate a gene count table
from this input data (FASTQ reads + reference genome files),
but as mentioned, we will not go through those steps ourselves.

Instead, I have generated a gene count table for you,
and we will now be doing differential expression analysis in R,
using the popular **DESeq2** package
([paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-014-0550-8),
[website](https://bioconductor.org/packages/release/bioc/html/DESeq2.html)).

<br>

## Getting set up

### Start an RStudio session at OSC

1. Log in to OSC at <https://ondemand.osc.edu>

2. Click on **`Interactive Apps`** (top bar) and then **`RStudio Server`** (all the way at the bottom)

3. Fill out the form as follows:
   - Cluster: **`Pitzer`**
   - R version: **`4.3.0`**
   - Project: **`PAS2250`**
   - Number of hours: **`4`**
   - Node type: **`any`**
   - Number of cores: **`2`**

<details><summary>_Click to see a screenshot_</summary>

![](img_de/rstudio_form.png){fig-align="center" width="50%"}

</details>
   
4. Click the big blue **`Launch`** button at the bottom

5. Now, you should be sent to a new page with a box at the top for your RStudio
   Server "job", which should initially be "Queued" (waiting to start).

<details><summary>_Click to see a screenshot_</summary>

![](img_de/rstudio_queued.png){fig-align="center" width="70%"}

</details>

6. Your job should start running very soon,
   with the top bar of the box turning green and saying "Running".

<details><summary>_Click to see a screenshot_</summary>

![](img_de/rstudio_running.png){fig-align="center" width="70%"}

</details>

7. Click **`Connect to RStudio Server`** at the bottom of the box,
   and an RStudio Server instance will open in a new browser tab.
   You're ready to go!

<hr style="height:1pt; visibility:hidden;" />

### Change two settings

_First_, we'll prevent R from saving your **"Workspace"**:

1. Click **`Tools`** (top bar, below your browser's address bar) > **`Global Options`**
2. In the pop-up window (stay on the `General` tab), change the settings under the
   "Workspace" heading to:
   
![](img_de/workspace.png){fig-align="center" width="45%"}

::: {.callout-tip collapse="true"}
#### Why are we doing this? _(Click to expand)_
In short, the default behavior of saving and restoring your "Workspace", which are all the
items (objects) that you create during an R session, is bad practice.
Instead, you should recreate your environment from a script and/or saved files
with individual pieces of data, as we'll do today.
:::

<hr style="height:1pt; visibility:hidden;" />

_Second_, we'll "update" our **pipe symbol** from `%>%` (the magrittr pipe that requires
a package to work) to `|>` (the new base R pipe that does not require a package):

1. Again click **`Tools`** > **`Global Options`** (you may still be there)
2. Now go to **`Code`** tab in the side panel on the left,
   and check the box for `Use native pipe operator, |> (requires R 4.1+)`
3. Click **`OK`** at the bottom of the pop-up window

![](img_de/rstudio_pipe.png){fig-align="center" width="70%"}

<hr style="height:1pt; visibility:hidden;" />

### Create a new RStudio Project

Using an "RStudio Project" will most of all help to make sure your working
directory in R is correct.

To create a new RStudio Project inside your personal dir in `/fs/scratch/PAS2250/ENT6703`:

1. Click **`File`** (top bar, below your browser's address bar) > **`New Project`**
2. In the popup window, click **`Existing Directory`**.

<details><summary>_Click to see a screenshot_</summary>

![](img_de/rstudio_proj_existingdir.png){fig-align="center" width="40%"}

</details>

3. Click **`Browse...`** to select your personal dir.

<details><summary>_Click to see a screenshot_</summary>

![](img_de/rstudio_proj_browse.png){fig-align="center" width="40%"}

</details>

4. In the next window, you should be in your Home directory (abbreviated as **`~`**),
   from which you can't click your way to `/fs/scratch`!
   Instead, you'll first have to click on the (very small!) **`...`** highlighted in the screenshot below:

![](img_de/rstudio_proj_dotdotdot_ed.png){fig-align="center" width="50%"}

5. Type at least part of the path to your personal dir (which is in `/fs/scratch/PAS2250/ENT6703`),
   e.g. as shown below, and click **`OK`**:

![](img_de/rstudio_proj_path.png){fig-align="center" width="35%"}

6. Now you should be able to browse/click the rest of the way to your personal directory.
5. Click **`Choose`** to pick your selected directory.
6. Click **`Create Project`**.

<hr style="height:1pt; visibility:hidden;" />

### Create an R script

We're going to write all our code in an R script instead of typing it directly in the console.
This helps us to **keep track of what we've been doing**, especially in the longer run,
and to be able to **re-run our code** after modifying input data or one of the lines of code.

Create and open a new R script by clicking
**`File`** (top menu bar) > **`New File`** > **`R Script`**.

Save this new script right away by clicking **`File`** > **`Save As`**,
then click **`New Folder`** and create a folder named "scripts".
Inside that folder, save the script with a name like **`lab4_DE.R`**
(the extension for R scripts is `.R`).

::: callout-important
#### Make sure to type all the R code below inside your script, and then send it to the console from there.
You can send code to the console by pressing <kbd>**Ctrl**</kbd> **+** <kbd>**Enter**</kbd>
on Windows, or <kbd>Cmd</kbd> + <kbd>Return</kbd> on a Mac.
:::

<hr style="height:1pt; visibility:hidden;" />

### Load the necessary packages

In R, we need to use "packages" (basically, add-ons) to perform specialized tasks
like differential expression analysis^[And even for more basic tasks, it is common to use packages that are preferred over the functionality that is by default available in R, like in the case of plotting.].
This is quite straightforward in principle, but at OSC, there can be some hickups and
at the very least, it will take much longer to install packages than on your own computer^[Yes, this may be surprising!].

I have therefore created a "library" (a directory with a collection of packages) for you ---
you can load the packages from that library, without needing to install them yourself.
Type the code below in your R script and send it to the R console:

```{r, eval=FALSE}
custom_library <- "/fs/scratch/PAS2250/ENT6703/share/rlib"

library(withr, lib.loc = custom_library)
library(tidyr, lib.loc = custom_library)
library(tidyverse, lib.loc = custom_library)       # Misc. data manipulation and plotting
library(DESeq2, lib.loc = custom_library)          # Differential expression analysis
library(EnhancedVolcano, lib.loc = custom_library) # Volcano plot
library(pheatmap, lib.loc = custom_library)        # Heatmap plot
```

```{r, echo=FALSE, warning=FALSE, message=FALSE}
if(! "pacman" %in% installed.packages()) install.packages("pacman")
packages <- c("DESeq2",          # Differential expression analysis
              "tidyverse",       # Misc. data manipulation and plotting
              "pheatmap")        # Heatmap plot
pacman::p_load(char = packages)
```

<hr style="height:1pt; visibility:hidden;" />

### Define our input files

For the differential expression analysis, we have the following input files:

- **Metadata table** --- The metadata we saw last week, to enable between-treatment comparisons
- **Gene counts table** --- Produced by running the [nf-core rnaseq workflow](https://nf-co.re/rnaseq) on the input data we saw last week

```{r, eval=FALSE}
count_table_file <- "../share/results/counts/salmon.merged.gene_counts_length_scaled.tsv"
metadata_file <- "../share/data/meta/metadata.tsv"
```

```{r, echo=FALSE}
count_table_file <- here::here("results/counts/salmon.merged.gene_counts_length_scaled.tsv")
metadata_file <- here::here("data/meta/metadata.tsv")
```

<br>

## Create a DESeq2 object

The DESeq2 package has its own "object type" (format) and before we can do anything
else, we need to create a DESeq2 object from three components:

1. **Metadata**  
   We should have all of our independent variables in columns in the metadata,
   which will allow DESeq2 to compare groups of samples
2. **Count table**  
   DESeq2 will of course need gene counts for its analysis.
   This table has one row per gene, and one column per sample.
   The sample IDs in the column names should match with those in the metadata.
3. **A statistical design**  
   Instead of telling DESeq2 about the statistical design (i.e., which groups to compare)
   on the fly when we run the analysis, we need to include this information in the object itself.

<hr style="height:1pt; visibility:hidden;" />

### Metadata

First, we'll load the metadata file and take a look at the resulting dataframe:

```{r}
# Read in the count table
meta_raw <- read_tsv(metadata_file, show_col_types = FALSE)
```

```{r, eval=FALSE}
# Take a look at the first 6 rows
head(meta_raw)
```

<details><summary>_Click to see the result_</summary>

```{r, echo=FALSE}
# Take a look at the first 6 rows
head(meta_raw)
```

</details>

We'll make sure the data frame is sorted by sample ID,
and that the sample IDs are contained in "row names":

```{r}
meta <- meta_raw |>
  # Sort by the 'sample_id' column
  arrange(sample_id) |>
  # Turn the 'sample_id' column into row names:
  column_to_rownames("sample_id") |>
  # Turn the 'time' and 'treatment' columns into "factors":
  mutate(time = factor(time, levels = c("24hpi", "10dpi")),
         treatment = factor(treatment, levels = c("control", "cathemerium", "relictum")))
```

```{r, eval=FALSE}
head(meta)
```

<details><summary>_Click to see the result_</summary>

```{r, echo=FALSE}
head(meta)
```

</details>

We changed the two columns with the independent variables (`time` and `treatment`)
into factors, because DESEq2 wants this --- and this also allowed us to use
a custom, non-alphanumeric ordering where `24hpi` comes before `10dpi`:

```{r}
head(meta$time)
```

<hr style="height:1pt; visibility:hidden;" />

### Count table

Second, we will load the count table into R:

```{r}
# Read in the count table
count_df <- read_tsv(count_table_file, show_col_types = FALSE)
```

```{r, eval = FALSE}
# Take a look at the first 6 rows
head(count_df)
```

<details><summary>_Click to see the result_</summary>

```{r, echo=FALSE}
# Take a look at the first 6 rows
head(count_df)
```

</details>

We next have to make several modifications, because DESeq2 expects an all-numeric matrix
with whole numbers (integers) and gene IDs are "row names" rather than as a separate
column:

```{r}
# Prepare the count table so it can be loaded into DESeq2
count_mat <- count_df |>
  # Turn the 'gene_id' column into row names:
  column_to_rownames("gene_id") |>
  # Remove a remaining non-numeric column, with gene names:
  select(-gene_name) |>
  # We should round everything to whole numbers:
  round() |>
  # We should convert it to a formal matrix format:
  as.matrix()
```

```{r, eval=FALSE}
# Take a look at the first 6 rows
head(count_mat)
```

<details><summary>_Click to see the result_</summary>

```{r, echo=FALSE}
# Take a look at the first 6 rows
head(count_mat)
```

</details>

#### Check that the sample IDs match

When creating the DESeq2 object, DESeq2 assumes that sample IDs in both tables match and 
are provided in the same order. Let's make sure this is indeed the case:

```{r}
all(row.names(meta) == colnames(count_mat))
```

<hr style="height:1pt; visibility:hidden;" />

### Create the DESeq2 object

We will create the DESeq2 object using the function `DESeqDataSetFromMatrix()`,
which we will provide with three arguments corresponding to the components
discussed above:

- The metadata with argument **`colData`**.
- The count data with argument **`countData`**.
- The statistical design for the DE analysis with argument **`design`**.
  For now, we will specify **`~1`**, which effectively means "no design" ---
  we will change this before the actual DE analysis.

```{r}
dds <- DESeqDataSetFromMatrix(colData = meta, countData = count_mat, design = ~ 1)
```

<hr style="height:1pt; visibility:hidden;" />

Before we will run the differential expression analysis, though, we will do
a bit of exploratory data analysis.

<br>

## Exploratory Data Analysis

### Our count matrix

What are number of rows and columns of the count matrix?

```{r}
dim(count_mat)
```

How many genes have non-zero counts?

```{r}
dim(count_mat[rowSums(count_mat) > 0, ])
```

<details><summary>**Your Turn**: How many genes have total counts of at least 10? _(Click to see the solution)_</summary>

```{r}
dim(count_mat[rowSums(count_mat) >= 10, ])
```

</details>

How are counts distributed across samples?
That is, we would like a sum of counts for each column:

```{r}
colSums(count_mat)
```

<details><summary>**Your Turn**: That's not that easy to read / interpret. Can you instead get these numbers in millions, rounded to whole numbers, and sorted? _(Click to see the solution)_</summary>

```{r}
sort(round(colSums(count_mat) / 1000000))
```

</details>

We can also simply print the `dds` object, which will give a summary of its contents:

```{r}
dds
```

<details><summary>**Bonus section**: Histograms of gene counts _(Click to expand)_</summary>

To plot a histogram of mean gene counts across samples,
we'll first create a data frame with these mean gene counts:

```{r}
mean_counts <- rowSums(count_mat) / ncol(count_mat)
mean_counts_df <- data.frame(mean_counts) |> 
  rownames_to_column("gene_id")
```

Now we can make the histogram:

```{r}
ggplot(mean_counts_df, aes(x = mean_counts)) +
  geom_histogram() +
  scale_y_log10() +
  theme_minimal()
```

Zoom in a bit:

```{r}
ggplot(mean_counts_df, aes(x = mean_counts)) +
  geom_histogram() +
  scale_y_log10() +
  scale_x_continuous(limits = c(0, 100000)) +
  theme_minimal()
```

Which genes have the highest counts?

```{r}
sort(rowSums(count_mat) / ncol(count_mat), decreasing = TRUE)[1:10]
```

</details>

<br>

### Principal Component Analysis (PCA) 

We will not run a Principal Component Analysis (PCA) to look for overall patterns
of (dis)similarity among our samples.
This will help us answer questions like:

- Do the samples cluster by treatment (infection status) and/or timepoint?
- Which of these two variables has a greater effect on overall levels of gene expression?
- Is there an overall interaction between these two variables?
  
First, we will have to normalize the count data to have even sampling across samples
(with respect to "library size", total number of reads per sample)
and approximately even variance:

```{r}
dds_vst <- varianceStabilizingTransformation(dds)
```

::: callout-tip
#### The authors of the study did this as well:
> _We carried out a Variance Stabilizing Transformation (VST) of the counts to represent the samples on a PCA plot._ 
:::

Next, we run and plot the PCA with a single function call, `plotPCA` from DESeq2
(the `ntop` argument refers to the top number of most variable genes to use for the PCA):

```{r, eval=FALSE}
plotPCA(dds_vst, ntop = 500, intgroup = c("time", "treatment"))
```

<details><summary>_Click to see the plot_</summary>

```{r, eval=TRUE, echo=FALSE}
plotPCA(dds_vst, ntop = 500, intgroup = c("time", "treatment"))
```

</details>

How does this compare to the PCA plot in the paper (their Fig. 1)?

<details><summary>**Your Turn**: Try to answer the three questions asked at the beginning of this PCA section. _(Click to see the solution)_</summary>

</details>

<details><summary>**Bonus Exercise**: Compare the plot with different values for `ntop`</summary>
</details>

<details><summary>**Bonus Section**: Customizing the PCA plot _(Click to expand)_</summary>

We'll do some customization to make the plot look better.
The biggest issue (I think) with the above plot is that each combination of 
time point and treatment has a distinct color ---
it would be better to use point colors only to distinguish one of the variables,
and point shape to distinguish the others (this is also how it was done in the
paper's Fig. 1).

First, if we use 

```{r}
pca_df <- plotPCA(dds_vst, ntop = 500, intgroup = c("time", "treatment"), returnData = TRUE)
```

We'll extract the percentage of variance explained by different principal components,
so we can later add this information to the plot:

```{r}
pct_var <- round(100 * attr(pca_df, "percentVar"), 1)
pct_var
```

```{r}
ggplot(pca_df,
       aes(x = PC1, y = PC2, color = treatment, shape = time)) +
  geom_point(size = 5) +
  labs(x = paste0("PC1 (", pct_var[1], "%)"),
       y = paste0("PC2 (", pct_var[2], "%)")) +
  scale_color_brewer(palette = "Dark2", name = "Infection status") +
  scale_shape(name = "Time points") +
  coord_fixed() +
  theme_bw() +
  theme(panel.grid.minor = element_blank())
```

</details>

<br>

## Differential Expression (DE) analysis

### Figuring out how to do the analysis

First, let's see how the DE analysis was done in the paper:

> _Then, we used the DESeq2 package (Love et al., 2014) to perform the differential gene expression analysis comparing: (i) P. relictum-infected mosquitoes vs. controls, (ii) P. cathemerium-infected mosquitoes vs. controls, and (iii) P. relictum-infected mosquitoes vs. P. cathemerium-infected mosquitoes._

This is not terribly detailed and could be interpreted in a couple of different ways.
For example, they may have compared infection statuses by ignoring time points or
by controlling for time points (and their are different ways to do the latter).

Ignoring time would mean analyzing the full dataset (all time points) while only
using the infection status as an independent variable, i.e. the design `~treatment`.

<details><summary>**Your Turn**: Given the PCA results, do you think that ignoring time is a good idea? _(Click to see the solution)_</summary>

Nope!

</details>

Controlling for time can additionally be done in two ways:

- A two-factor analysis: `~ time + treatment`
- Pairwise comparisons between each combination of time and treatment
  (we'll see below _how_ we can do that)

If we take a look at Table 1 with the DE results, it will become clearer how
they did their analysis:

![](img_de/paper_table1.png){fig-align="center" width="80%"}

It looks like they performed pairwise comparisons between each combination of time and treatment.
But this can in turn be done in two ways with DESeq2:

- After subsetting the dataset to each combination of time and treatment.
- After creating a single independent variable that is a combination of time and treatment.

The latter method is the more common one, and is what we will do below^[I can't tell from the paper which method they used].

<hr style="height:1pt; visibility:hidden;" />

### Setting the statistical design

As discussed above, we will now create a new variable that is a combination
of `treatment` and `time`, and we'll call it `group`:

```{r}
# Create a combined variable called 'group':
dds$group <- factor(paste(dds$treatment, dds$time, sep = "_"))

# Which unique values does 'group' have, and how many samples are in each?
table(dds$group)
```

Next, we set the analysis design:

```{r}
design(dds) <- ~ group
```

Now we're ready to run the DE analysis!

<hr style="height:1pt; visibility:hidden;" />

### Running the DE analysis

We perform the differential expression analysis with the `DEseq()` function:

```{r}
dds <- DESeq(dds)
```

::: callout-tip
Note that we above, we assigned the output back to the `dds` object ---
in this case, the DE results are being _added_ to the object!
:::

The `DESeq()` function is a wrapper that performs three steps (functions) consecutively:
  
- `estimateSizeFactors()` --- "Normalization" by library size and composition.
- `estimateDispersions()` --- Estimate gene-wise dispersion (variance in counts).
- `nbinomWaldTest(ddsObj)` --- Fit the negative binomial GLM and calculate
  Wald statistics, which is the test statistic underlying the DE p-value.

::: callout-note
### More about gene count normalization

Note that *DESeq2* doesn’t actually normalize the counts in the sense that
it produces a matrix with adjusted counts.
Instead it uses raw counts and includes the size factors in the modeling.
To learn more about gene count normalization, see
[this video](https://www.youtube.com/watch?v=UFB993xufUU) and
[this page](https://hbctraining.github.io/DGE_workshop/lessons/02_DGE_count_normalization.html).

:::

<br>

## Extracting the DE results

A key thing to understand is that DESeq2 has automatically performed **pairwise**
comparisons between **each of the (6) levels** of the `group` variable.

As such, we can extract a separate table with gene-wise results for each of these (15) pairwise
comparisons.
Or put differently, for any individual gene, it tested whether this gene is differentially
expressed separately for each of the pairwise comparisons.

<hr style="height:1pt; visibility:hidden;" />

### The results table

We can extract the results for one pairwise comparison
(which DESeq2 refers to as a **contrast**) at a time,
by specifying it with the `contrast` argument as a vector of length 3:

1. The focal independent variable (here, `group`)
2. The first (reference) level of the independent variable (in the example below, `relictum_24hpi`)
3. The second level of the independent variable (in the example below, `control_24hpi`)

```{r}
res_rc24 <- results(dds, contrast = c("group", "relictum_24hpi", "control_24hpi"))
head(res_rc24)
```

What do the columns in this table contain?

- **`baseMean`**: Mean expression level across all samples.
- **`log2FoldChange`**: The "log2-fold change" of gene counts between the compared levels.
- **`lfcSE`**: The uncertainty in terms of the standard error (SE) of the log2-fold change estimate.
- **`stat`**: The value for the Wald test's test statistic.
- **`pvalue`**: The *uncorrected* p-value from the Wald test.
- **`padj`**: The multiple-testing corrected p-value (i.e., adjusted p-value).

::: callout-note
#### Log2-fold changes
Log2-fold changes are the standard way of representing the *effect size* of expression
level differences between two groups of interest.

A log2-fold change of 1 indicates that the expression in the reference level
is two-fold *lower* than that of the other level,
a log2-fold change of 2 indicates a four-fold difference,
a log2-fold change of 3 indicates an eight-fold difference, and so on.
  
Similarly, *negative log2-fold* values indicate a change in gene counts in the
other direction: the reference level is *higher* than the other level.
:::

::: callout-note
#### Multiple testing correction
Because we are testing significance for *many* genes,
we need to correct for multiple testing.
DESeq2 uses the Benjamini-Hochberg False Discovery Rate (FDR) correction.

For more info, see: STATQUEST
:::

How many adjusted p-values were less than 0.05?

```{r}
sum(res_rc24$padj < 0.05, na.rm = TRUE)
```

So, we have `r sum(res_rc24$padj < 0.05, na.rm = TRUE)` Differentially Expressed
Genes (**DEG**s) for this specific pairwise comparison.

How does that compare to what they found in the paper?

<details><summary>**Your Turn:** The paper's Table 1 also reports numbers of up- and downregulated genes separately. Can you find this out for our DEGs? _(Click to see the solution)_</summary>

</details>

<details><summary>**Your Turn:** The paper's Table 1 also reports the number of DEGs with an absolute log2-fold change greater than 1. Can you find this out for our DEGs? _(Click to see the solution)_</summary>

</details>

<details><summary>**Your Turn:** Extract the results for one or more other contrasts that are the paper's Table 1, and compare the results.</summary>
</details>

<details><summary>**Bonus section**: `NA` values in the results table _(Click to expand)_</summary>

Some values in the results table can be set to `NA` for one of the following reasons:

- If a gene contains a sample with a count **outlier**,
  both the p-value and adjusted p-value will be set to `NA`.
  (DESeq2 performs outlier detection using Cook's distance.)
  
- If all samples have **zero counts** for a given gene,
  the `baseMean` column will be zero,
  and the log2-fold change estimates,
  p-value and adjusted p-value will all be set to `NA`.

- DESeq2 also automatically filters genes with a **low mean count**
  in the sense that it does not include them in the multiple testing correction.
  Therefore, in such cases, the p-value will not be `NA`,
  but the *adjusted* p-value will be.
  
  Because we have very low power to detect differential expression for such
  low-count genes, it is beneficial to remove them prior to the multiple testing
  correction: that way, the correction becomes less severe for the remaining genes.

Let's see how many genes have `NA` p-values:

```{r}
# Number of genes with NA p-value:
sum(is.na(res_rc24$pvalue))

# As a proportion of the total number of genes in the test:
sum(is.na(res_rc24$pvalue)) / nrow(res_rc24)
```

And `NA` adjusted p-values:

```{r}
# Number of genes with NA p-value:
sum(is.na(res_rc24$padj))

# As a proportion of the total number of genes in the test:
sum(is.na(res_rc24$padj)) / nrow(res_rc24)
```

</details>

<details><summary>**Bonus section**: Exporting the results _(Click to expand)_</summary>

You may be wondering how we can save the DE results tables:

```{r, eval=FALSE}
# Create the output directory, if necessary:
dir.create("results/DE", recursive = TRUE, showWarnings = FALSE)

# Write the 
write_tsv(as.data.frame(res_rc24), "results/DE/resultsres_rc24.tsv")
```

</details>

<br>

## Visualizing the DE results

We will create a few plots for the results for the `relictum_24hpi` vs. `control_24hpi`
comparison, which we extracted above.

### Volcano plot

For a nice overview of the results, we can plot a so-called "volcano plot"
using the `EnhancedVolcano()` function from the package of the same name
([see here for a "vignette" / tutorial](https://bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html)):

```{r, fig.height=6.5, eval=FALSE}
EnhancedVolcano(
  toptable = res_rc24,      # DESeq2 results to plot   
  title = "relictum vs. control at 24 hpi",
  x = "log2FoldChange",     # Plot the log2-fold change along the x-axis
  y = "pvalue",             # Plot the p-value along the y-axis
  lab = rownames(res_rc24), # Use the rownames for the gene labels (though see below)
  labSize = 0               # Omit gene labels
  )
```

<details><summary> _Click to see the plot_</summary>

```{r, fig.height=6.5, echo=FALSE}
EnhancedVolcano(
  toptable = res_rc24,      # DESeq2 results to plot   
  title = "relictum vs. control at 24 hpi",
  x = "log2FoldChange",     # Plot the log2-fold change along the x-axis
  y = "pvalue",             # Plot the p-value along the y-axis
  lab = rownames(res_rc24), # Use the rownames for the gene labels (though see below)
  labSize = 0               # Omit gene labels
  )
```

</details>

::: callout-note
#### Plot customization ideas

Above, we turned the gene labeling off by setting `labSize = 0` ---
the default p-value cut-off for point labeling is `1e-5` (and the default log2-fold
change cut-off is `1`): in this case, that would get quite busy with gene labels.
We might want to try a plot with a stricter p-value cut-off that does show the gene labels.

Some further ideas for potential customization:

- We might want to get rid of the subtitle ("EnhancedVolcano") and the caption ("total=...").
- Perhaps you want to exclude the outlier with the >20 log2-fold change.
- Conversely, you might want to _label_ the abovementioned outlier.
- You might want to try some other options you see in
  [this vignette](https://bioconductor.org/packages/release/bioc/vignettes/EnhancedVolcano/inst/doc/EnhancedVolcano.html)
  or the help page which you can access by running `?EnhancedVolcano`.
:::

<details><summary>**Your Turn:** Consider some of the ideas above and customize the plot (_Click for an example_) </summary>

```{r, fig.height=6.5}
EnhancedVolcano(
  toptable = res_rc24,      
  title = "relictum vs. control at 24 hpi",
  x = "log2FoldChange",     
  y = "pvalue",             
  lab = rownames(res_rc24), 
  labSize = 3,               # Now we will show the gene labels
  pCutoff = 10e-10,          # Modify the p-value cut-off
  subtitle = NULL,           # Remove the subtitle
  caption = NULL,            # Remove the caption
  )
```

<details><summary>**Your Turn:** Figure out the identity of the abovementioned log2-fold change outlier either by labeling it in the plot, or by filtering the `res_rc24` table (_Click for the solution_) </summary>

- By labeling it in the plot:

```{r, fig.height=6.5}
EnhancedVolcano(
  toptable = res_rc24,      
  title = "relictum vs. control at 24 hpi",
  x = "log2FoldChange",     
  y = "pvalue",             
  lab = rownames(res_rc24), 
  labSize = 3,               
  pCutoff = 10e-4,           # Modify the p-value cut-off
  FCcutoff = 20,
  )
```

- By filtering the results table:
```{r}
as.data.frame(res_rc24) |> filter(log2FoldChange > 20)
```

</details>

<hr style="height:1pt; visibility:hidden;" />

### Plot specific genes

We can also create plots of expression levels for individual genes.
That is especially interesting for genes with highly significant differential
expression. So let's plot the most highly significant DEG.

First, let's create a vector with most highly signifant DEGs,
which we'll use again for the heatmap below.

```{r}
top25_DE <- row.names(res_rc24[order(res_rc24$padj)[1:20], ])

top25_DE
```

DESeq2 has a plotting function but the plot is not very good.
We will still use that function to quickly extract the counts for our gene of interest
in the right format for plotting, using `returnData = TRUE` (which will also make it omit the plot):

```{r}
focal_gene_counts <- plotCounts(
  dds,
  gene = top25_DE[1],
  intgroup = c("time", "treatment"),
  returnData = TRUE
  )
```

```{r, eval=FALSE}
head(focal_gene_counts)
```

<details><summary>_Click to see the result_</summary>

```{r, echo=FALSE}
# Take a look at the first 6 rows
head(focal_gene_counts)
```

</details>

Now we can make the plot:

```{r, eval=FALSE}
ggplot(focal_gene_counts, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  geom_point(size = 4, shape = 21, position = position_jitter(w = 0.1, h = 0)) +
  facet_wrap(vars(time)) +
  theme_bw() +
  theme(legend.position = "none")
```

<details><summary> _Click to see the plot_</summary>

```{r, echo=FALSE}
ggplot(focal_gene_counts, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  geom_point(size = 4, shape = 21, position = position_jitter(w = 0.1, h = 0)) +
  facet_wrap(vars(time)) +
  theme_bw() +
  theme(legend.position = "none")
```

</details>

<details><summary>**Your Turn:** Plot the gene with the very high log-fold change value that we saw when making the volcano plot. _(Click for the solution)_</summary>

```{r}
focal_gene_counts <- plotCounts(
  dds,
  gene = "LOC120431476",
  intgroup = c("time", "treatment"),
  returnData = TRUE
  )

ggplot(focal_gene_counts, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  geom_point(size = 4, shape = 21, position = position_jitter(w = 0.1, h = 0)) +
  facet_wrap(vars(time)) +
  theme_bw() +
  theme(legend.position = "none")
```

</details>

<details><summary>**Bonus Exercise:** Plot one or a few more of the top-DE genes. Do they have similar expression patterns across treatment and timepoints as the first one?</summary>

</details>

<hr style="height:1pt; visibility:hidden;" />

### Heatmaps

We can create heatmaps with the `pheatmap` function.
Let's start by creating a function that will plot a heatmap given a vector
of gene IDs and a DESeq2 object `dds`:

```{r}
norm_mat <- assay(dds_vst)
```

```{r}
norm_mat_sel <- norm_mat[match(top25_DE, rownames(norm_mat)), ]
meta_sort <- meta |>
  arrange(treatment, time) |>
  select(treatment, time)
```

```{r, eval=FALSE}
pheatmap(norm_mat_sel,
         cluster_rows = TRUE,
         cluster_cols = FALSE,
         show_rownames = FALSE,
         annotation_col = meta_sort,
         scale = "row")
```

<details><summary> _Click to see the plot_</summary>

```{r, echo=FALSE}
pheatmap(norm_mat_sel,
         cluster_rows = TRUE,
         cluster_cols = FALSE,
         show_rownames = FALSE,
         annotation_col = meta_sort,
         scale = "row")
```

</details>

<details><summary>**Your Turn:** Make a heatmap with the top-25 most-highly expressed genes _(Click for a hint: how to get that top-25)_</summary>

```{r}
top25_hi <- names(sort(rowMeans(norm_mat), decreasing = TRUE)[1:20])
```

</details>

<details><summary> _Click for the solution_</summary>

```{r}
norm_mat_sel <- norm_mat[match(top25_hi, rownames(norm_mat)), ]
meta_sort <- meta |>
  arrange(treatment, time) |>
  select(treatment, time)

pheatmap(norm_mat_sel,
         cluster_rows = TRUE,
         cluster_cols = FALSE,
         show_rownames = FALSE,
         annotation_col = meta_sort,
         scale = "row")
```

</details>

<hr style="height:1pt; visibility:hidden;" />

<br>

## In Closing

### Next steps

Some potential next steps for this analysis are:

- Run the DE analysis for all pairwise comparisons
- Compare DEGs across pairwise
  (this would allow us to make the upset plot in Figure 2 of the paper)
- Perm
- Enrichment analysis


<br>
